<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>electricity</title>
<style>
  :root{
    --bg:#0b0b0f;
    --panel:#0f1720;
    --neon-a:#00e5ff;
    --neon-b:#7cff00;
    --accent:#ffcc00;
    --muted:#9aa3b2;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Segoe UI,Arial,sans-serif;color:#e6f0ff;}
  .container{max-width:1100px;margin:18px auto;padding:18px;display:grid;grid-template-columns:360px 1fr;gap:18px;}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.6);}
  h1{margin:0 0 8px 0; font-size:20px; letter-spacing:0.6px;}
  .hud {display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:10px;}
  .score {background:linear-gradient(90deg,rgba(0,229,255,0.06),rgba(124,255,0,0.03));padding:8px 12px;border-radius:10px;font-weight:700;color:var(--neon-a);box-shadow:0 4px 10px rgba(0,229,255,0.06) inset;}
  .level {padding:8px 12px;border-radius:10px;background:rgba(255,204,0,0.06);color:var(--accent);font-weight:700;}
  .controls {display:flex;gap:8px;align-items:center;}
  .btn {background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e6f0ff;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}
  .btn.primary{background:linear-gradient(90deg,var(--neon-a),var(--neon-b));color:#021018;border:none;box-shadow:0 6px 20px rgba(0,229,255,0.08);}
  .small {font-size:13px;color:var(--muted);}
  .hearts {font-size:18px;color:#ff6b6b;font-weight:700;}
  .goal {margin-top:10px;padding:10px;background:rgba(255,255,255,0.02);border-radius:10px;color:var(--muted);}
  .canvasWrap{display:flex;flex-direction:column;align-items:center;}
  canvas{border-radius:10px;background:linear-gradient(180deg,#07070a,#0d0f12);display:block;box-shadow:0 12px 30px rgba(0,0,0,0.6);border:2px solid rgba(255,255,255,0.03);}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  .chip{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);font-weight:600;color:var(--neon-a);border:1px solid rgba(0,229,255,0.06);}
  /* Right column: info & start screen */
  .meta{display:flex;flex-direction:column;gap:12px;}
  .panel .sectionTitle{font-size:14px;color:var(--muted);margin-bottom:6px;}
  .progressBar{height:12px;background:rgba(255,255,255,0.03);border-radius:10px;overflow:hidden;}
  .progress{height:100%;background:linear-gradient(90deg,var(--neon-a),var(--neon-b));width:0%;}
  .startScreen{display:flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;padding:18px;border-radius:8px;}
  .instructions{font-size:13px;color:var(--muted);line-height:1.4;}
  footer{grid-column:span 2;margin-top:10px;text-align:center;color:rgba(255,255,255,0.15);font-size:13px;}
  @media(max-width:880px){.container{grid-template-columns:1fr;}.panel{margin-bottom:10px}}
</style>
</head>
<body>

<div class="container">
  <!-- LEFT: Controls / Info -->
  <div class="panel">
    <h1>⚡ Stickman — Electricity Lab (Grade 9)</h1>
    <div class="hud">
      <div>
        <div class="score" id="scoreUI">Score: 0</div>
        <div class="small" style="margin-top:6px" id="collectedUI">Collected: —</div>
      </div>
      <div style="text-align:right">
        <div class="level" id="levelUI">Level 1 / 20</div>
        <div class="hearts" id="heartsUI">♥♥♥♥♥</div>
      </div>
    </div>

    <div class="goal" id="goalUI">Goal: —</div>

    <div style="display:flex;gap:8px;margin-top:12px;">
      <button class="btn primary" id="startBtn">Start</button>
      <button class="btn" id="stopBtn">Pause</button>
      <button class="btn" id="restartBtn">Restart</button>
      <div style="flex:1"></div>
    </div>

    <div style="margin-top:12px;">
      <div class="sectionTitle">Level Progress</div>
      <div class="progressBar"><div class="progress" id="progressBar"></div></div>
    </div>

    <div style="margin-top:12px">
      <div class="sectionTitle">Instructions</div>
      <div class="instructions">
        Use ← and → to move the stickman. Catch the <strong>right components</strong> to build circuits listed in the goal. Catching a wrong component costs a heart. Finish a level to earn bonus points and advance.
      </div>
    </div>

    <div style="margin-top:12px">
      <div class="sectionTitle">Legend</div>
      <div class="legend">
        <div class="chip">B = Battery</div>
        <div class="chip">L = Lamp</div>
        <div class="chip">R = Resistor</div>
        <div class="chip">W = Wire</div>
        <div class="chip">S = Switch</div>
        <div class="chip">C = Capacitor</div>
        <div class="chip">D = Diode</div>
      </div>
    </div>
  </div>

  <!-- RIGHT: Game Canvas -->
  <div class="panel canvasWrap">
    <canvas id="gameCanvas" width="860" height="480"></canvas>
    <div style="display:flex;gap:12px;margin-top:12px;align-items:center;">
      <div class="small">Controls: ← →</div>
      <div style="flex:1"></div>
      <div class="small" id="statusUI">Status: Ready</div>
    </div>
  </div>

  <footer>Save this file in VS Code, then open in browser (right-click → Open with Live Server is easiest). Enjoy teaching electricity!</footer>
</div>

<script>
/* ========== GAME CONFIG ========== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const SCORE_BONUS_PER_LEVEL = 100;
const POINT_PER_CORRECT = 10;
const POINT_PENALTY_WRONG = 5;
const START_HEARTS = 5;
const MAX_LEVELS = 20;

/* ====== LEVELS: each level has a name and recipe of components needed.
   Components use one-letter codes for display:
   B = Battery, L = Lamp (bulb), R = Resistor, W = Wire, S = Switch, C = Capacitor, D = Diode
   Recipes are intentionally progressive — later levels require more pieces & faster spawn.
*/
const levels = [
  {name:"Simple Circuit", recipe:{B:1,L:1,W:2}},
  {name:"Switch Circuit", recipe:{B:1,L:1,S:1,W:2}},
  {name:"Resistor Lamp", recipe:{B:1,R:1,L:1,W:2}},
  {name:"Two Lamps", recipe:{B:1,L:2,W:3}},
  {name:"Parallel Lamps", recipe:{B:1,L:2,W:4,R:2}},
  {name:"Capacitor Charge", recipe:{B:1,C:1,W:2}},
  {name:"Diode Indicator", recipe:{B:1,D:1,L:1,W:2}},
  {name:"Series Resistors", recipe:{B:1,R:2,W:3}},
  {name:"Switch + Resistor", recipe:{B:1,S:1,R:1,L:1,W:3}},
  {name:"Multiple Components", recipe:{B:1,L:2,R:1,W:4}},
  {name:"Complex Circuit I", recipe:{B:1,L:2,R:2,W:5}},
  {name:"Complex Circuit II", recipe:{B:2,L:2,R:2,W:6}},
  {name:"Sensor Starter", recipe:{B:1,C:1,D:1,W:3}},
  {name:"Capacitor Bank", recipe:{B:1,C:2,W:4}},
  {name:"Logic Gate Prep", recipe:{B:2,D:2,W:6}},
  {name:"Power Array", recipe:{B:2,L:3,W:6,R:2}},
  {name:"Control Circuit", recipe:{B:2,S:2,R:2,W:6}},
  {name:"Protection Circuit", recipe:{B:2,D:2,C:1,W:6}},
  {name:"Advanced I", recipe:{B:3,L:3,R:3,W:8}},
  {name:"Advanced II", recipe:{B:3,L:4,R:3,W:10,C:1}}
];

/* ========== STATE ========== */
let state = {
  levelIndex: 0,
  score: 0,
  hearts: START_HEARTS,
  objects: [],     // falling objects
  collected: {},   // counts for current recipe
  running: false,  // game loop running?
  spawnTimer: null,
  lastSpawnDelay: 1000,
  stick: {x:420,y:400,w:48,h:60},
  keys: {},
  paused: false
};

/* ========== UI ELEMENTS ========== */
const scoreUI = document.getElementById('scoreUI');
const levelUI = document.getElementById('levelUI');
const heartsUI = document.getElementById('heartsUI');
const goalUI = document.getElementById('goalUI');
const collectedUI = document.getElementById('collectedUI');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const restartBtn = document.getElementById('restartBtn');
const statusUI = document.getElementById('statusUI');
const progressBar = document.getElementById('progressBar');

/* ====== UTILS ====== */
function formatRecipe(recipe){
  return Object.entries(recipe).map(([k,v]) => `${v}${k}`).join(' + ');
}
function updateUI(){
  scoreUI.textContent = `Score: ${state.score}`;
  levelUI.textContent = `Level ${state.levelIndex+1} / ${MAX_LEVELS}`;
  heartsUI.textContent = '♥'.repeat(state.hearts);
  const level = levels[state.levelIndex];
  goalUI.textContent = `Goal: ${level.name} → ${formatRecipe(level.recipe)}`;
  // collected display
  const parts = [];
  for (let k in level.recipe){
    const have = state.collected[k] || 0;
    parts.push(`${k}: ${have}/${level.recipe[k]}`);
  }
  collectedUI.textContent = `Collected: ${parts.join(' · ')}`;
  // progress bar: fraction of required items collected relative to total required (capped)
  const need = Object.values(level.recipe).reduce((a,b)=>a+b,0);
  const have = Object.keys(level.recipe).reduce((s,k)=> s + Math.min(state.collected[k]||0, level.recipe[k]), 0);
  progressBar.style.width = `${Math.round((have/need)*100)}%`;
}

/* ====== GAME LOGIC ====== */
function resetCollected(){
  state.collected = {};
  const recipe = levels[state.levelIndex].recipe;
  for (let k in recipe) state.collected[k]=0;
}

function spawnObject(){
  // component pool: include correct components plus distractors
  const pool = ['B','L','R','W','S','C','D','X','Y']; // X,Y are wrong distractors
  // increase chance for needed components as level grows
  const recipe = levels[state.levelIndex].recipe;
  const weighted = [];
  // add recipe components multiple times
  for (let k of pool){
    let weight = 1;
    if (recipe[k]) weight += recipe[k]*2; // needed ones heavier
    // level scaling: more wrong items as level increases
    if (k==='X' || k==='Y') weight += Math.floor(state.levelIndex/3);
    for (let i=0;i<weight;i++) weighted.push(k);
  }
  const type = weighted[Math.floor(Math.random()*weighted.length)];
  const obj = {
    type,
    x: Math.random() * (canvas.width - 30) + 10,
    y: -20,
    speed: 1 + 0.6*state.levelIndex + Math.random()*1.4 // increases with level
  };
  state.objects.push(obj);
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function collectObject(obj){
  const level = levels[state.levelIndex];
  if (level.recipe[obj.type] !== undefined){
    // correct
    state.collected[obj.type] = (state.collected[obj.type] || 0) + 1;
    state.score += POINT_PER_CORRECT;
    statusUI.textContent = `Nice! +${POINT_PER_CORRECT}`;
  } else {
    // wrong: lose heart and penalty
    state.hearts -= 1;
    state.score = Math.max(0, state.score - POINT_PENALTY_WRONG);
    statusUI.textContent = `Wrong! -1 heart, -${POINT_PENALTY_WRONG} pts`;
    if (state.hearts <= 0){
      gameOver();
      return;
    }
  }
  updateUI();
  checkLevelComplete();
}

function checkLevelComplete(){
  const level = levels[state.levelIndex];
  for (let k in level.recipe){
    if ((state.collected[k]||0) < level.recipe[k]) return;
  }
  // Completed level
  state.score += SCORE_BONUS_PER_LEVEL;
  statusUI.textContent = `Level Complete! +${SCORE_BONUS_PER_LEVEL} bonus`;
  // brief pause and then next level
  pauseGameFor(900, () => {
    state.levelIndex++;
    if (state.levelIndex >= MAX_LEVELS || state.levelIndex >= levels.length){
      // finished all levels
      alert(`Fantastic! You finished the course.\nFinal Score: ${state.score}`);
      restartGame();
      return;
    }
    resetForNextLevel();
  });
}

function resetForNextLevel(){
  state.objects = [];
  resetCollected();
  // slightly shrink spawn delay to make game harder
  state.lastSpawnDelay = Math.max(300, 1200 - state.levelIndex * 40);
  updateUI();
}

/* ====== GAME LOOP ====== */
let lastTime = 0;
function gameLoop(ts){
  if (!state.running || state.paused){ lastTime = ts; requestAnimationFrame(gameLoop); return; }
  const dt = ts - lastTime;
  lastTime = ts;
  // move stickman based on keys
  if (state.keys.ArrowLeft) state.stick.x -= 6;
  if (state.keys.ArrowRight) state.stick.x += 6;
  state.stick.x = clamp(state.stick.x, 0, canvas.width - state.stick.w);

  // update objects
  for (let i = state.objects.length - 1; i >= 0; i--){
    const o = state.objects[i];
    o.y += o.speed * (dt/16);
    // collision with stickman
    if (o.y + 18 >= state.stick.y && o.y <= state.stick.y + state.stick.h){
      if (o.x + 18 > state.stick.x && o.x < state.stick.x + state.stick.w){
        // collected
        collectObject(o);
        state.objects.splice(i,1);
        continue;
      }
    }
    // remove if fallen beyond canvas
    if (o.y > canvas.height + 30) state.objects.splice(i,1);
  }

  // render
  render();

  requestAnimationFrame(gameLoop);
}

/* ====== RENDER ====== */
function render(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background grid / glow
  ctx.fillStyle = "#05060a";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // neon ground line
  ctx.strokeStyle = "rgba(0,229,255,0.06)";
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0,460); ctx.lineTo(canvas.width,460); ctx.stroke();

  // draw stickman (white/neon)
  drawStickman(state.stick.x, state.stick.y);

  // draw falling objects
  for (let o of state.objects){
    drawComponent(o);
  }
}

/* draw stickman simple stylized */
function drawStickman(x,y){
  ctx.save();
  ctx.translate(x, y);
  ctx.strokeStyle = "rgba(230,240,255,0.95)";
  ctx.lineWidth = 2;
  // head
  ctx.beginPath(); ctx.arc(24,10,10,0,Math.PI*2); ctx.stroke();
  // body
  ctx.beginPath(); ctx.moveTo(24,20); ctx.lineTo(24,40); ctx.stroke();
  // arms
  ctx.beginPath(); ctx.moveTo(24,26); ctx.lineTo(4,32); ctx.moveTo(24,26); ctx.lineTo(44,32); ctx.stroke();
  // legs
  ctx.beginPath(); ctx.moveTo(24,40); ctx.lineTo(6,56); ctx.moveTo(24,40); ctx.lineTo(42,56); ctx.stroke();
  ctx.restore();
}

/* draw component as neon pill with letter */
function drawComponent(o){
  ctx.save();
  const w = 36, h = 22;
  // color mapping
  const colors = {
    B: ['#00e5ff','#007a8a'],
    L: ['#ffdd55','#8a6a00'],
    R: ['#7cff00','#356400'],
    W: ['#dcdcdc','#999999'],
    S: ['#ff79c6','#7a4056'],
    C: ['#8a7bff','#3a2a80'],
    D: ['#ff7a50','#803a2a'],
    X: ['#6b6b6b','#2f2f2f'],
    Y: ['#6b6b6b','#2f2f2f']
  };
  const pal = colors[o.type] || ['#ffffff','#999999'];
  // neon glow
  ctx.shadowBlur = 18;
  ctx.shadowColor = pal[0];
  // pill
  ctx.fillStyle = pal[0];
  roundRect(ctx, o.x, o.y, w, h, 8, true, false);
  // inner darker stripe
  ctx.shadowBlur = 0;
  ctx.fillStyle = pal[1];
  roundRect(ctx, o.x+2, o.y+3, w-4, h-6, 6, true, false);
  // letter
  ctx.fillStyle = "#041016";
  ctx.font = "bold 16px Inter,Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(o.type, o.x + w/2, o.y + h/2);
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (r === undefined) r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* ====== INPUT HANDLING ====== */
window.addEventListener('keydown', e => {
  state.keys[e.key] = true;
});
window.addEventListener('keyup', e => {
  state.keys[e.key] = false;
});

/* ====== START / STOP / RESTART / PAUSE logic ====== */
function startGame(){
  if (state.running && !state.paused) return;
  if (!state.running){
    // initialize
    state.levelIndex = 0;
    state.score = 0;
    state.hearts = START_HEARTS;
    state.objects = [];
    resetCollected();
    state.lastSpawnDelay = 1000;
    state.stick.x = (canvas.width - state.stick.w)/2;
  }
  state.running = true;
  state.paused = false;
  statusUI.textContent = "Running";
  startSpawnLoop();
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

function stopGame(){
  // pause
  if (!state.running) return;
  state.paused = !state.paused;
  statusUI.textContent = state.paused ? "Paused" : "Running";
  if (!state.paused){
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }
}

function restartGame(){
  // reset everything
  state.running = false;
  clearSpawnLoop();
  state.levelIndex = 0;
  state.score = 0;
  state.hearts = START_HEARTS;
  state.objects = [];
  resetCollected();
  updateUI();
  statusUI.textContent = "Ready";
  // small visual refresh
  render();
}

/* ====== spawn loop handles spawn rate scaling with level ====== */
function startSpawnLoop(){
  clearSpawnLoop();
  // spawn initial spacing based on level
  state.lastSpawnDelay = Math.max(350, 1200 - state.levelIndex * 40);
  state.spawnTimer = setInterval(() => {
    if (!state.running || state.paused) return;
    spawnObject();
    // adjust spawn speed gradually with higher level
    const newDelay = Math.max(320, 1200 - state.levelIndex * 48 - Math.random()*300);
    if (Math.abs(newDelay - state.lastSpawnDelay) > 0.5){
      clearSpawnLoop();
      state.lastSpawnDelay = newDelay;
      startSpawnLoop();
    }
  }, state.lastSpawnDelay);
}

function clearSpawnLoop(){ if (state.spawnTimer) { clearInterval(state.spawnTimer); state.spawnTimer = null; } }

function pauseGameFor(ms, cb){
  state.paused = true;
  statusUI.textContent = "Good job! Preparing next level...";
  setTimeout(()=>{
    state.paused = false;
    statusUI.textContent = "Running";
    cb && cb();
  }, ms);
}

function gameOver(){
  clearSpawnLoop();
  state.running = false;
  statusUI.textContent = "Game Over";
  alert(`Game Over! Your score: ${state.score}`);
  // auto restart to allow replay
  restartGame();
}

/* ====== wiring buttons ====== */
startBtn.addEventListener('click', ()=>{
  startGame();
});
stopBtn.addEventListener('click', ()=>{
  stopGame();
});
restartBtn.addEventListener('click', ()=>{
  if (confirm("Restart the game?")) restartGame();
});

/* ====== init ====== */
resetCollected();
updateUI();
render();
statusUI.textContent = "Ready";

/* ====== small helper to update UI every 200ms so numbers are fresh ====== */
setInterval(updateUI, 200);

</script>
</body>
</html>